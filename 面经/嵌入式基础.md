# 嵌入式计算机的发展

当前计算机的发展，有两种类型

|       类型       |       技术要求       |                     技术发展方向                     |
| :--------------: | :------------------: | :--------------------------------------------------: |
|  通用计算机系统  | 高速、海量的数值计算 |            更快的总线速度，更大的存储容量            |
| 嵌入式计算机系统 | 对象的智能化控制能力 | 与对象系统密切相关的嵌入性能、控制能力与控制的可靠性 |

把微处理器、I/O接口、RAM ROM等部件统统集成到一个VLSI中，从而制造出面向**I/O**设计的微控制器，即单片机。

## 嵌入式计算机系统的定义

**嵌入式系统是指以应用为中心，以计算机技术为基础，软件硬件可剪裁，适应应用系统对功能、成本、体积、功耗严格要求的专用计算机系统。**

## 嵌入式计算机系统的组成

+ 嵌入式微处理器
+ 外围设备
+ 嵌入式操作系统
+ 用户应用软件等部分组成

# 嵌入式处理器及外围设备

嵌入式处理器及外围设备属于嵌入式系统的硬件架构

## 嵌入式处理器组成

嵌入式处理器包含：

+ 处理器内核
+ 地址总线
+ 数据总线
+ 控制总线
+ 处理器本身的辅助支撑电路，如时钟、复位电路
+ 片上I/O接口电路

## 嵌入式处理器的分类

+ 嵌入式微处理器(Micro Processing Unit,MPU)

+ 嵌入式微控制器(Micro Control Unit,MCU),俗称单片机

+ 嵌入式DSP(Digital Signal Processor)

  > **嵌入式DSP**专门用来对离散时间信号进行极快的处理计算，提高编译效率和执行速度。DSP正在大量进入数字滤波、FFT、谱分析、图像处理等领域。

**嵌入式微处理器**与**通用微处理器**的对比：

+ 相似点：对外的接口和指令处理功能
+ 不同点：指令系统中指令的个数，MPU更少；指令的形式，MPU一般使用精简指令集；处理器的架构设计；处理器的工艺和应用指标

# CPU

## CPU的指令集RISC、CISC

CPU的指令集分为RISC和CISC两种

+ RISC(Reduced Instruction Set Computing):精简指令集。精简CISC的指令。
+ CISC(Complex Instruction Set Computer)：复杂指令集。

---

两者区别：

+ RISC大多指令**在一个时钟周期**内完成，且指令长度统一、数目少；而CISC的复杂指令通过CPU内的微码来完成，需要多个时钟周期，且指令长度不一、数目多。

+ RISC较CISC**更易实现指令流水线**，因为其指令大多在一个时钟周期内完成。
+ RISC控制器多采用硬件连线控制方式，以期更快的执行速度；而CISC控制器绝大多数采用微程序控制方式。





## CPU的内部架构和工作原理

CPU从逻辑上可以分为：

+ 控制单元
+ 运算单元
+ 存储单元
+ 时钟

---

+ 控制单元：CPU的指挥控制中心
  + PC程序计数器：当前正在执行指令的地址。在每个指令获取之后，程序计数器指向顺序中的下一个指令。
  + IR指令寄存器：暂存当前正在执行的指令。

+ 运算单元：运算器的核心。执行算数、逻辑运算等。
+ 存储单元：是CPU暂时存放数据的地方，包括CPU片内缓存和寄存器组。

---

CPU的工作原理是：

**控制单元**在时序脉冲的作用下，将**程序计数器**里所指向的指令地址送到地址总线上去，然后CPU将这个地址里的指令读到**指令寄存器**进行译码。对于执行指令过程中所需要用到的数据，会将数据地址也送到地址总线，然后CPU把数据读到CPU的**内部存储单元**(就是内部寄存器)暂存起来，最后命令**运算单元**对数据进行处理加工。这个过程不断重复，直到程序结束。

## CPU的内核态和用户态

多数CPU都有两种模式，即**内核态**与**用户态**。

在PSW(Program Status Word)程序状态字寄存器，有一个二进制位控制这两种模式。

+ 在用户态下运行，仅允许执行整个指令集的一个子集和访问所有功能的一个子集。用户态则只能访问一部分指令。
+ 当在内核态运行时，CPU可以执行指令集中的每一条指令，并且使用硬件的每一种功能。内核态拥有最高权限，可以访问所有系统指令；

> 危险指令：设置时钟、清内存等。

# 嵌入式流水线工作

嵌入式CPU为了更高的效率，采用的是**超流水线**结构

>在普通流水线中，CPU执行一条指令被拆成了五个步骤，每个步骤执行时间可能都是1ns，但是有一个长指令，拆分成五个步骤时，指令执行（Execute）这个步骤却需要2ns，那整个流水线的效率就受制于指令执行Execute）这个步骤了。

所以为了提高效率，我们可以把指令执行（Execute）这个步骤再拆分成两组（寄存器+组合逻辑），每组执行时间为1ns，这样我们的普通流水线成了六级流水线了，这就是**超流水线**。

# 乱序执行

乱序执行（out-of-order execution）是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理的技术。比方Core乱序执行引擎说程序某一段有7条指令，此时CPU将根据各单元电路的空闲状态和各指令能否提前执行的具体情况分析后，将能提前执行的指令立即发送给相应电路执行。在各单元不按规定顺序执行完指令后还必须由相应电路再将运算结果重新按原来程序指定的指令顺序排列后才能返回程序。

# CPU的两种体系结构，有什么区别

+ 冯诺伊曼结构
+ 哈佛结构

---

+ 冯诺伊曼结构：公用的数据存储空间和程序存储空间
+ 哈佛结构：分离的数据和程序空间，分离的访问总线。具有更高的执行效率。

# 缓冲技术的作用

+ 改善CPU与I/O设备间速度不匹配的矛盾。
+ 提高CPU和I/O设备之间的并行性，提高系统的吞吐量和设备的利用率。
+ 减少对CPU中断的频率，放款对中断响应时间的限制。

---

缓冲包括：单缓冲、双缓冲、多缓冲和缓冲池。

# ROM RAM的区别

| 存储器类型 |                           简介                           |                             作用                             |
| :--------: | :------------------------------------------------------: | :----------------------------------------------------------: |
|    ROM     |              只读存储器（Read-Only Memory）              | 是一种只能读出事先所存数据的固态半导体存储器。其特性是一旦储存资料就无法再将之改变或删除。 |
|    RAM     | 随机存取存储器（random access memory）又称作“随机存储器” | 是与CPU直接交换数据的内部存储器，也叫主存(内存)。它可以随时读写，而且速度很快。 |

# 哪些嵌入式系统

+ Linux

  嵌入式Linux（Embedded Linux）是**标准Linux**经过小型化裁剪处理之后的专用Linux操作系统，能够固化于容量只有几KB或者几MB的存储器芯片或者单片机中，适合于特定嵌入式应用场合。目前已经开发成功的嵌入式系统中，大约一半的系统使用嵌入式Linux。

+ VxWoirks

+ QNX

+ Windows CE

+ Palm OS

+ uc/OS

# 什么是DMA

**DMA**是指外部设备不通过CPU而直接与系统内存交换数据的接口技术。这样数据的传送速度就取决于存储器和外设的工作速度。DMA的出现就是为了解决批量数据的输入/输出问题。DMA的一个周期是指存储周期。

# FreeRTOS、uCOS的区别

+ FreeRTOS内核ROM和耗费RAM都比uCOS小。

+ FreeRTOS可以用协程(Co-routine)，减少RAM消耗。

  uCOS只能用任务(TASK,每个TASK要有独立的栈)

+ FreeRTOS可以有优先度一样的任务，这些任务是按照时间片来轮流处理的，uCOS每个任务都只有一个独一无二的优先级。所以FreeRTOS可以管理超过64个软件，uCOS最多控64个。
+ uCos任务通讯方式比FreeRTOS多一些，外延支持也多一点。

# 中断场景和注意事项

+ 使用场景：

  针对实时性要求较高的场景下，可以使用中断来处理外部信号，以做到及时响应。如按键等。

+ 注意事项：

  1. 裸机程序下，中断不能**进行参数传递，没有返回值。**
  2. 对于实时性不高的场景，尽量不设置中断。
  3. 中断内，代码要少，不要放延时。
  4. 不要频繁使用中断来打断主流程的运行。

# ARM微处理器的特点

采用RISC架构的ARM微处理器有以下特点：

+ 体积小、功耗低、低成本、高性能。
+ 大量使用寄存器，指令执行速度很快
+ 指令长度固定。
+ 除此以外，ARM体系结构还采用了一些特别的技术，在保证高性能的前提下尽量缩小芯片的面积，并降低功耗：
  1. 所有的指令都可根据前面的执行结果决定是否被执行，从而提高指令的执行效率。
  2. 可用加载/存储指令批量传输数据，以提高数据的传输效率。
  3. 可在一条数据处理指令中同时完成逻辑处理和移位处理。
  4. 在循环处理中使用地址的自动增减来提高运行效率。
  5. 支持协处理器来扩展ARM的功能

## 用过哪些ARM系列

ARM7 9 11 系列，Cortex系列

## Cortex和SecurCore各自的优势

+ Cortex**系列：Cortex-M3处理能力相当于ARM7，处理器结合了多种突破性技术，令芯片供应商提供超低费用的芯片。该处理器还集成了许多紧耦合系统外设，令系统能满足下一代产品的控制需求。Cortex的优势应该在于**低功耗**、**低成本**、**高性能**3者（或2者）的结合。
+ **SecurCore**系列：SecurCore系列涵盖了SC100、SC110、SC200和SC210微处理器核。该系列处理器主要针对**新兴的安全市场**，以一种全新的安全处理器设计为智能卡和其他安全IC开发提供独特的32位系统设计，并具有特定的反伪造方法，从而有助于防止对硬件和软件的盗版。

## 介绍下Cortex-m3处理器

主要包括：

1、寄存器组2、地址功能划分映射3、中断机制（NVIC）。

1. 寄存器组

   共有19组32位寄存器：R0-R12通用寄存器、R8-R12堆栈指针寄存器。、R15程序寄存器(指当前执行程序的地址)

2. 地址功能划分映射

   使用**小端模式**，也支持大端模式

   Cortex-m3是一个32位处理器，其地址总线、数据总线都是32位的，故可在4G的地址范围上资源寻址。Cortex-m3内核把**4G空间**划定了基本的框架，定义不同的使用用途。

   0x0000 0000 ----0x1FFF FFFF (512MB) 该区域为code区（flash区），供指令总线与数据总线取指取数使用；可以执行指令；

   0x2000 0000 ----0x3FFF FFFF (512MB) 该区域为片上SRAM区，芯片制造商可在此布设RAM，可以将代码复制到此处运行，该区域也是可以执行指令code的；低1MB空间可位寻址，通过位带别名可扩展为32Mb的位寻址。

   0x4000 0000 ----0x5FFF FFFF (512MB)该区域为"片上外设"区 ，主要为片上外设的相关寄存器，即特殊功能寄存器区，同理低1MB也可位寻址；该区域不可执行代码；

3. 中断机制

   CM3中用8位来编程中断的优先级数，可实现256级优先级。

## ARM 微处理器模式有哪些？

+ **用户模式**（**Usr**，User Mode）：ARM处理器正常的程序执行状态。
+ **快速中断模式**（**FIQ**，Fast Interrupt Request Mode）：用于高速数据传输或通道处理。当触发快速中断时进入此模式。
+ **外部中断模式**（**IRQ**，Interrupt Request Mode）：用于通用的中断处理。当触发外部中断时进入此模式。
+ **管理模式**（**Svc**，Supervisor Mode）：操作系统使用的保护模式。在系统复位或执行软件中断指令SWI时进入。
+ **数据访问中止模式**（**abt**，Abort Mode）：当数据或指令预取中止时进入该模式，可用于虚拟存储及存储保护。
+ **系统模式**（**sys**，System Mode）：运行具有特权的操作系统任务。
+ **未定义指令中止模式**（**und**，Undefined Mode）：当未定义的指令执行时进入该模式，可用于支持硬件协处理器的软件仿真。

除了用户模式之外，其余六种模式都是**特权模式**。除了用户模式和系统模式之外，其余五种模式都是**异常模式**。

## ARM处理器几种模式的切换过程

1. 执行软中断（SWI）或复位命令（Reset）指令。如果在用户模式下执行SWI指令，CPU就进入管理（**Supervisor**）模式。
2. 有外部中断发生。如果发生了外部中断，CPU就会进入**IRQ**或**FIQ**模式。
3. CPU执行过程中产生异常。最典型的异常是由于MMU保护所引起的内存访问异常，此时CPU会切换到**Abort**模式。如果是无效指令，则会进入**Undefined**模式。
4. 有一种模式是CPU无法自动进入的，这种模式就是**System**模式，要进入System模式必须由程序员编写指令来实现。因此一般情况下，操作系统在通过SWI进入**Supervisor**模式后，做一些操作后，就进入System模式。

# ARM的寄存器与存储器

ARM的31个通用寄存器R0~R15中，程序计数器PC为R15、程序链接寄存器LR为R14、堆栈指针寄存器SP为R13。

## **寄存器掉电会丢失数据吗？**

寄存器是由触发器构成的，因此掉电会丢失数据。

# 嵌入式中断的流程

**IRQ中断和FIQ中断都属于ARM的异常模式**。在ARM系统中，一旦有中断发生，不管是外部中断，还是内部中断，正在执行的程序都会停下来。接下来通常会按照如下步骤处理中断：

1. **保存现场**。保存当前的PC值到R14，寄存器R14常用作**链接寄存器**（LR，Link Register），当进入子程序时，常用来保存PC（Program Counter，程序计数器） 的返回值。保存PC值后，接着保存当前的程序运行状态到SPSR（Storage Program Status Register，程序状态备份寄存器）。
2. **模式切换**。根据发生的中断类型，进入IRQ模式或FIQ模式。
3. **获取中断源**。以异常向量表保存在低地址处为例，若是IRQ中断，则PC指针跳动0x18处（`0x18：LDR PC, IRQ_ADDR`）；若是FIQ中断，则跳到0x1C处（`0x1c：LDR PC, FIQ_ADDR`）。IRQ和FIQ的异常向量地址处一般保存的是中断服务子程序的地址，所以接下来PC指针跳入中断服务子程序处理中断。
4. **中断处理**。
5. 中断返回，恢复现场。当完成中断服务子程序后，将SPSR中保存的程序运行状态恢复到CPSR（Current Program Status Register，当前程序状态寄存器）中，R14中保存的被中断程序的地址恢复到PC中，继续执行被中断的程序。

# 中断和异常的区别是什么？

异常与中断不同，它在产生时必须考虑与处理器时钟同步。实际上，异常也常常称为同步中断。在处理器执行到由于编程失误而导致的错误指令（例如被0除）的时候，或者在执行期间出现特殊情况（例如缺页），必须靠内核来处理的时候，处理器就会产生一个**异常**。

中断的工作方式与之类似，其差异只在于**中断是由硬件而不是软件引起的**。

# 复位中断和其他中断的区别

+ 当中断产生后，复位中断立即中止当前指令的执行，其余情况都是当处理器完成当前指令后，再去响应中断。

+ 如果是复位中断，系统自动从0x00000000开始重新执行程序，无需中断返回。

# 大端模式和小端模式

**小端模式**：**低**的有效字节存储在**低的**存储器地址。常用的X86结构是小端模式。很多的ARM，DSP都为小端模式。

**大端模式**：**高**的有效字节存储在**低的**存储器地址。C51则为大端模式。

---

（1）大端优点：符号位在低地址的第一个字节中，便于快速判数据的正负和大小。

（2）小端优点：CPU做数值运算的时候是依次从内存的低位到高位取数据进行运算，这样运行效率更高。强制转换数据不需要调整字节内容，因为1、2、4字节数据的存储方式一样。

# 什么是MMU，工作原理是什么

1. **MMU**(Memory Management Unit)主要用来管理虚拟内存、物理内存的控制线路，同时也负责虚拟地址映射为物理地址。

   如果处理器没有MMU，或者有MMU但没有启用，CPU执行单元发出的内存地址将直接传到芯片引脚上，被内存芯片（以下称为物理内存，以便与虚拟内存区分）接收，这称为物理地址（Physical Address，以下简称PA）

   如果处理器启用了MMU（一般是在bootloader中的eboot阶段的进入main()函数的时候启用），CPU执行单元发出的内存地址将被MMU截获，从CPU到MMU的地址称为虚拟地址（Virtual Address，以下简称VA），而MMU将这个地址翻译成另一个地址发到CPU芯片的外部地址引脚上，也就是将VA映射成PA

   大多数使用MMU的机器都采用分页机制。虚拟地址空间以页为单位进行划分（对于32位的CPU，通常一页为4k），而相应的物理地址空间也被划分，其使用的单位称为页帧，页帧和页必须保持相同，因为内存与外部存储器之间的传输是以页为单位进行传输的。

2. MMU的作用：一是扩大地址空间，二是内存保护与共享，三是避免内存碎片

# 谈谈TLB

**TLB**（Translation Lookaside Buffer），也就是**高速后备缓冲区**，在TLB中可以存放一部分段表中的内容。当CPU访问内存时，先访问TLB查找访问的内存映射关系是否存放在TLB中。如果在，则从TLB中读取映射关系，否则再去访问内存中的段表，从段表中读取映射关系，并把相应的结果添加到TLB中，更新它的内容。**这样CPU下一次又需要该地址映射关系的话，就可以直接从TLB取得**。因为TLB的访问速度比内存的访问速度要快得多，如果采取一定的技术，使访问TLB的命中率比较高的话，就可以大大提高访问内存的速度。

简单来说，**TLB就是映射表的缓存**。

# 谈谈DSP

DSP（digital singnal processor）是一种独特的微处理器，是以数字信号来处理大量信息的器件。其工作原理是接收模拟信号，转换为0或1的数字信号，再对数字信号进行修改、删除、强化，并在其他系统芯片中把数字数据解译回模拟数据或实际环境格式。采用**哈佛结构**，将程序和数据空间分开，可以同时访问指令和数据；**DSP优势**在于其有独特乘法器，一个指令就可以完成乘加运算。并且同时访问指令和数据，大大提高效率。

# DPS与ARM的区别

+ ARM处理器广泛的使用在许多嵌入式系统。ARM处理器的特点有指令长度固定，执行效率高，低成本，低功耗等。ARM内部资源丰富，外部外设接口丰富，通用性好。偏重控制。
+ DSP偏重运算，有独特乘法器，一个指令就可以完成乘加运算，适合于信号、图像等需要大量数字运算的地方。

# 谈谈STM32

## STM32F103

### 、中断机制

异常或者中断是处理器响应系统中突发事件的一种机制。当异常发生时，Cortex—M3通过硬件自动将编程计数器（PC）、编程状态[寄存器](http://www.elecfans.com/tags/寄存器/)（XPSR）、链接寄存器（LR）和R0～R3、R12等寄存器压进堆栈。在Dbus（数据总线）保存处理器状态的同时，处理器通过Ibus（指令总线）从一个可以重新定位的向量表中识别出异常向量，并获取ISR函数的地址，也就是保护现场与取异常向量是并行处理的。一旦压栈和取指令完成，中断服务程序或故障处理程序就开始执行。执行完ISR，硬件进行出栈操作，中断前的程序恢复正常执行。图1为Cortex—M3处理器的异常处理流程。

## STM32F750

# 单片机如何选型

+ 考虑项目需求。
  + 需要几个I2C SPI UART
  + 需要多大内存
  + 是否需要A/D D/A
  + 功耗、抗干扰等
+ 选择较为常用的单片机，资料多。
+ 考虑成本

# 用过传感器吗

传感器的指标：量程、线性度、灵敏度、分辨力、漂移。

零位漂移现象，可以通过电桥来补偿。

# BootLoader

**BootLoader**就是在运行操作系统内核之前所运行的一段小程序。通过这段小程序，可以对系统的硬件设备进行初始化、建立内存空间的映射图，从而将系统的软、硬件设置成一个合适的环境，以便为最终调用操作系统内核做好准备。**嵌入式BootLoader的核心任务就是引导嵌入式操作系统运行起来**。

## 同一个BootLoader可以运行在不同的板子上吗？

不行，对于两块不同的嵌入式板而言，即使它们是基于同一种CPU而构建的，如果它们的硬件资源和配置不一致，要想让运行在一块板子上的BootLoader程序也能运行在另一块板子上，还需要对BootLoader进行**裁剪和移植**。

## BootLoader启动步骤：

BootLoader的**stage1**通常包括以下步骤：

- 硬件设备初始化。
- 为加载BootLoader的stage2准备**RAM**空间。
- 复制BootLoader的stage2到**RAM**空间中。
- 设置好堆栈。
- 跳转到stage2的C入口点。

BootLoader的**stage2**通常包括以下步骤：

- 初始化本阶段要使用的硬件设备。
- 检测系统内存映像。
- 将kernel映像和根文件系统映像从Flash上读到RAM空间中。
- 为内核设置启动参数。
- 调用内核。

## 谈谈自己熟悉的BootLoader

U-Boot，全称Universal Boot Loader，是遵循GPL条款的开放源码项目。**其源码目录、编译形式与Linux内核很相似**，

但是U-Boot不仅仅支持嵌入式Linux系统的引导，还支持相当多的操作系统，**这是U-Boot中Universal的一层含义**；其U-Boot主要有如下优点：

- 开放源码；
- 支持多种嵌入式操作系统内核，如Linux、NetBSD, VxWorks, QNX,RTEMS, ARTOS, LynxOS；
- 支持多个处理器系列，如PowerPC、ARM、x86、MIPS、XScale；
- 较高的可靠性和稳定性；[插图] 高度灵活的功能设置，适合U-Boot调试、操作系统不同引导要求、产品发布等；
- 丰富的设备驱动源码，如串口、以太网、SDRAM、Flash、NVRAM、EEPROM、LCD、键盘等；
- 较为丰富的开发调试文档与强大的网络技术支持。

## BootLoader的两种模式

+ 启动加载模式：这种模式也称为“自主”（autonomous）模式。也即BootLoader从目标机上的某个固态存储设备上将操作系统加载到RAM中运行，整个过程并没有用户的介入。这种模式是BootLoader的正常工作模式，因此在嵌入式产品发布时，BootLoader显然必须工作在这种模式下。
+ 下载模式：在这种模式下，目标机上的BootLoader将通过串口连接或网络连接等通信手段从主机（host）下载文件，比如：下载更新的BootLoader、下载内核映像和根文件系统映像等。

# 什么是驱动程序

一个驱动程序就是一个函数和数据结构的集合，它的目的是**建立内核和实际硬件**之间的连接，从而提供通过内核访问底层硬件的上层API接口。内核用这个接口请求驱动程序控制设备的I/O操作。

# 说一说设备的种类，各自有什么特点

Linux支持三种不同类型的设备：

+ 字符设备 character devices
+ 块设备 blockdevices
+ 网络接口 network interfaces

---

1. **字符设备**以字节为单位进行数据处理，一般不使用缓存技术。大多数字符设备仅仅是数据通道，**只能按顺序读/写**（但是也有些字符设备可以实现随机读/写）。典型的字符设备有：鼠标、键盘、I/O设备等。字符设备驱的源码一般在目录drivers/char中。
2. **块设备**数据可以按可寻址的块为单位进行处理，块的大小通常为512B到32 KB不等。大多数块设备**允许随机访问**，而且常常采用缓存技术。块设备有：硬盘、光盘驱动器等。文件系统一般都要求能随机访问，因此通常采用块设备。
3. **网络接口**用于网络通信，可能针对某个硬件，如网卡或纯软件，如loopback。网络接口只是面向数据包而不是数据流，所以内核的处理也不同，没有映射成任何设备文件，而是按照UNIX标准给它们分配一个唯一的名字。

# 交叉编译

**交叉编译**，就是：在一种平台上编译，编译出来的程序，是放到别的平台上运行即编译的环境，和运行的环境不一样，属于交叉的，此所谓cross，此所谓：在x86平台上编译，在ARM平台上运行

之所以要有交叉编译，主要原因是：嵌入式系统中的资源太少。没办法进行本地编译

# Linux设备驱动开发有哪些API

open（） close（） read（） write（）等

# I2C

I2C总线只有两根双向信号线：

+ 数据线SDA：双向数据线
+ 时钟线SCL：**边沿触发**，上升沿：主机->I2C设备；下降沿：I2C设备->主机。

## I2C的时序图

I2C总线的五种状态：

+ 空闲状态。SDA与SCL均为高电平。
+ 起始信号。SCL为高电平时，SDA由高->低。
+ 数据传送。SCL为高电平时，SDA的电平保持稳定，SDA是低电平为数据0，SDA是高电平为数据1。
+ 停止信号。SCL为高电平时，SDA由低到高。
+ 应答信号ACK。SCL为高电平时，SDA保持低电平。IIC总线上所有数据都是以8位字节传送的，发送器每发送一个字节，就在第9个时钟脉冲期间释放SDA（高电平），由接收器反馈一个ACK。
+ 非应答信号NACK。在SCL保持高电平期间，SDA保持高电平。如果接收器是主控器，则它在收到最后一个字节后，发送一个NACK，通知被控器结束数据发送，并释放SDA（高电平），以便主控器发送一个STOP。

I2C的传输数据图：

![img](https://uploadfiles.nowcoder.com/images/20210329/675098158_1617022927783/09DD8C2662B96CE14928333F055C5580)

+ 首先SCL和SDA均为高电平，空闲状态。
+ SCL保持高电平，SDA突然由高到低，产生传输起始信号。
+ 开始传输数据。
  + 主机在每个SDA产生时钟脉冲，将在SDA线上传输一个数据位，**按照数据位从高到低传输**。
  + 拉低SDA，保持一段时间，回传给主设备一个应答位ACK，认为一个字节传输完成。
+ SDA由低到高，SCL保持高电平，发出停止信号。

## I2C如何选择从设备

**2C通信的时候，通信双方地位是不对等的，而是分为主设备和从设备。通信由主设备发起，由主设备主导，从设备只是按照I2C协议被动的接收主设备的通信，并及时响应。**

系统中的所有外围器件通常具有一个**7位的从器件专用地址码**，其中高4位为器件类型，由生产厂家制定，低3位为器件引脚定义地址，由使用者定义（I2C还支持10位寻址）。

# SPI

SPI是串行外设接口，是**高速的，全双工，同步**的通信总线。

使用**主从方式**工作，通常有一个主设备和多个从设备。

通常需要**4**根线，事实上3根也可以。

+ SD**O**/M**O**SI Master Output/Slave Input-主出从入
+ SD**I**/MIS**O**  主入从出
+ SCLK 时钟线
+ CS/SS 片选线

## SPI工作模式，由什么决定

SPI总线有四种工作方式(SP0, SP1, SP2, SP3)，其中使用的最为广泛的是SPI0和SPI3方式。SPI模块为了和外设进行数据交换，根据外设工作要求，其输出**串行同步时钟**的**极性**和**相位**可以进行配置，如表格所示：

| SPI模式 | 时钟极性 (CPOL) | 时钟相位 (CPHA) | 空闲状态下的时钟极性 |                 采样                 |
| :-----: | :-------------: | :-------------: | :------------------: | :----------------------------------: |
|   SP0   |        0        |        0        |      逻辑低电平      | 第一个跳变沿 (上升或下降) 数据被采样 |
|   SP1   |        0        |        1        |      逻辑低电平      | 第二个跳变沿 (上升或下降) 数据被采样 |
|   SP2   |        1        |        1        |        高电平        | 第二个跳变沿 (上升或下降) 数据被采样 |
|   SP3   |        1        |        0        |        高电平        | 第一个跳变沿 (上升或下降) 数据被采样 |

**时钟极性 (CPOL)** 对传输协议没有重大的影响。如果CPOL=0，串行同步时钟的空闲状态为低电平；如果CPOL=1，串行同步时钟的空闲状态为高电平。

**时钟相位 (CPHA)** 能够配置用于选择两种不同的传输协议之一进行数据传输。如果 CPHA=0，在串行同步时钟的第一个跳变沿 (上升或下降) 数据被采样；如果CPHA=1，在串行同步时钟的第二个跳变沿 (上升或下降) 数据被采样。

**SPI主模块和与之通信的外设时钟相位和极性应该一致**。

SPI接口有**四种不同**的数据ss传输时序，取决于**CPOL**和**CPHL**这两位的组合。

# UART

在串口通讯的协议层中，规定了数据包的内容，它由**起始位，主体数据，校验位以及停止位**组成，通讯双方的**数据包格式以及波特率要约定一致**才能正常收发数据。    

当没有数据发送时

+ 空闲位：处于逻辑**1**

数据准备发送时：

+ 起始位：先发出一个逻辑**0**信号，表示传输字符的开始
+ 数据位：5-8位的逻辑**0或1**，如ASCII(7位)、扩展BCD码(8位)
+ 校验位：可选。分为偶校验和奇校验
+ 停止位：一个字符数据的结束标志位，可以是1位、1.5位或2位

## UART使用的场景

+ 计算机通用设备接口
+ 调试系统

## UART 波特率

波特率：每秒传输的码元数。如波特率9600 = 每秒传输**9600/8=1200个**字节

## 常用的数据校验算法

+ 奇偶校验：只需要在数据上添加一个额外的位，这个额外的位称为奇偶校验位。
  + 奇校验，则当接收端收到这组代码时，校验“1”的个数是否为奇数，
  + 偶校验，则当接收端收到这组代码时，校验“1”的个数是否为偶数，

## 硬件流量控制

**流**：数据流，即流量控制。

数据在两个串口之间进行传输时，常会出现丢失数据的现象。

+ 两台计算机的处理速度不同。
+ 接收端数据缓冲区已满，则此时继续发送来的数据就会丢失。

流控制如何解决这个问题？

当接收端数据处理不来时，就发出“**不再接收”**的信号，发送端就会停止发送，直到收到“**可以继续发送**”的信号再发送数据

PC机中常用到的硬件流控制：RTS/CTS、DTR/DSR等。

硬件流控制必须将相应的电线连上，数据终端设备（如计算机）使用RTS来请求发送数据，而数据通讯设备（如调制解调器）则用CTS来清除和暂停来自计算机的数据流。

这种硬件握手方式的过程为：在编程时，根据接收端缓冲区大小设置一个高位标志（可为缓冲区大小的75％）和一个低位标志（可为缓冲区大小的25％），当缓冲区内数据量达到高位时，我们在接收端将CTS线置低电平（送逻辑0），当发送端的程序检测到CTS为低后，就停止发送数据，直到接收端缓冲区的数据量低于低位而将CTS置高电平。RTS则用来标明接收设备有没有准备好接收数据。

| 引脚 |     意义     | 电平 |
| :--: | :----------: | :--: |
| CTS  | 停止发送数据 |  0   |
| CTS  | 可以发送数据 |  1   |
| RTS  | 停止接收数据 |  0   |
| RTS  | 可以接收数据 |  1   |

## UART与USART的区别

UART与USART都是单片机上的串口通信，他们之间的区别如下：

UART：universal asynchronous receiver and transmitter通用异步收/发器

USART: universal synchronous asynchronous receiver and transmitter通用**同步/异步**收/发器

从名字上可以看出，USART在UART基础上增加了同步功能，即USART是UART的增强型。

其实当我们使用USART在异步通信的时候，它与UART没有什么区别，但是用在同步通信的时候，区别就很明显了：大家都知道同步通信需要时钟来触发数据传输，也就是说USART相对UART的区别之一就是能提供主动时钟。

# 说说你了解的总线

| 总线 |                              线                              | 半双工/全双工 | 串行/并行 | 同步/异步 |                          速率                           |
| :--: | :----------------------------------------------------------: | :-----------: | :-------: | :-------: | :-----------------------------------------------------: |
| I2C  |                 SCL（时钟线）和SDA（数据线）                 |    半双工     |   串行    |   同步    | 标准（100kbit/s），快速（400kbit/s）和高速（3.4Mbit/s） |
| SPI  | SDI（串行数据输入）、SDO（串行数据输出）、SCK（串行移位时钟）、CS（从使能） |    全双工     |   串行    |   同步    |                一般传输速度能达到20Mbp/s                |
| UART |            至少三根：RX（接收）、TX（发送）和GND             |    全双工     |   串行    |   异步    |                     一般为9.6kbit/s                     |
| CAN  |                         CAN_H和CAN_L                         |    半双工     |   串行    |   异步    |                      最高可达1MB/s                      |
| USB  |                      Vbus、GND、D+、D-                       |    半双工     |   串行    |   同步    |                   快，USB3.0可达5Gbps                   |

# RS232和RS485的区别

1. **RS232接口的信号电平值较高(1 = 3-15V,0 = 3-15V)**，易损坏接口电路的芯片，又因为与TTL 电平不兼容故需使用电平转换电路方能与TTL电路连接；RS-485接口信号电平比RS-232降低了，就不易损坏接口电路的芯片，且该电平与TTL电平兼容，可方便与TTL 电路连接。

2. RS232**传输速率较低**，在异步传输时，波特率为20Kbps；RS-485的数据最高传输速率为10Mbps 。

3. **RS232接口****使用两根信号线和一根地线**返回而构成共地的传输形式，容易产生共模干扰，所以抗噪声干扰性弱；**RS-485接口是****双线制**，采用平衡驱动器和差分接收器的组合，抗共模干能力增强，即抗噪声干扰性好。

4. **RS232传输距离有限**，最大传输距离标准值为50英尺，实际上也只能用在50米左右；RS-485接口的最大传输距离标准值为4000英尺，实际上可达3000米

5. **RS232全双工**，**RS485半双工**工作方式

   > **共模信号就是二个大小相等、方向相同的信号。**导线做去路，地线做返回路。
   >
   > **差模信号就是二个大小相等、方向相反的信号。**两根导线分别做为往返线路

# 串行和并行的区别

1. **数据传送方式不同**：串行口传输方式为数据排成一行、一位一位送出数据；并行口传输8位数据一次送出。
2. **针脚不同**：串行口针脚少，消耗IO资源少；并行口针脚多，消耗IO资源多。
3. **用途不同**：串行口主要用在速度要求不高、有一定距离的传输场景，如UART，I2C通信；并行口多用于传输速率要求高、吞吐量大的场景，如FSMC（Flexible Static Memory Controller，可变静态存储控制器），DVP（Digital Video Port，数字视频接口）等接口。

# 说一说同步和异步的区别

1. 同步通信要求**接收端时钟频率**和**发送端时钟频率**一致，发送端发送连续的比特流，字节与字节之间没有间隙；异步通信时不要求接收端时钟和发送端时钟同步，发送端发送完一个字节后，可经过任意长的时间间隔再发送下一个字节。
2. 同步通信效率高，异步通信效率较低。
3. 同步通信较复杂，双方时钟的允许误差较小；异步通信简单，双方时钟可允许一定误差。
4. 同步通信可用于多点对多点，异步通信只适用于点对点。

# 什么是半工，半双工，全双工

![img](https://i.loli.net/2021/07/12/rS7Ukyd1EFT4nBf.png)

+ 半双工只有**一条数据线**，既要用作发送数据，又要用作接收数据，是单向的；

+ 全双工**有两条数据****线**，一条数据线用作发送数据，一条数据线用作接收数据，是双向的。

那么两者最大区别就是速率了，**全双工通信速率理论上是半双工的两倍**。

# SRAM  DRAM SDRAM的区别

（1）SRAM：静态的随机存储器，加电情况下，不需要刷新，数据不会丢失，**CPU的缓存**就是SRAM。

（2）DRAM：动态随机存储器，加电情况下，也需要不断刷新，才能保存数据，**最为常见的系统内存**。

（3）SDRAM：同步动态随机存储器，即数据的读取需要时钟来同步，也可用作内存。

