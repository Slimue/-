# 操作系统的来历

+ 操作系统可以对计算机系统的各项资源板块开展**调度**工作，包括**软硬件系统、数据信息**等。

+ 为了更好的人机交互，是用户程序与计算机硬件的桥梁。

# 操作系统的功能

1. CPU管理：工作主要是**进程调度**。在多任务多用户情况下，组织多个作业或任务时，就要解决处理器的调度、分配和回收等问题。
2. 存储管理
3. 设备管理
4. 文件管理
5. 作业管理：负责处理用户提交的任何要求

# CPU

## CPU的工作原理

**控制单元**在时序脉冲的作用下，将**程序计数器**里所指向的指令地址送到地址总线上去，然后CPU将这个地址里的指令读到**指令寄存器**进行译码。对于执行指令过程中所需要用到的数据，会将数据地址也送到地址总线，然后CPU把数据读到CPU的**内部存储单元**(就是内部寄存器)暂存起来，最后命令**运算单元**对数据进行处理加工。这个过程不断重复，直到程序结束。

## CPU的流水线

经典MIPS五条流水线将执行的生命周期分为5个部分：

+ 取值
+ 译码
+ 执行
+ 访存
+ 写回

# 内核态与用户态的区别

1. 属性上：内核态(系统态)与用户态是操作系统的两种运行级别。内核态拥有最高权限，可以访问所有系统指令。用户态只能访问一部分指令。
2. 什么时候需要进入内核态：
   + 系统调用(**主动**进入)
   + 系统异常(被动进入)
   + 设备中断(被动进入)

3. 为什么要有区分：

   在CPU的指令中，有些指令错用将导致整个系统崩溃。出于安全考虑进行封闭。

# 系统调用

Linux内核设置了一组用于实现各种系统功能的子程序，统称为**系统调用**。

系统调用由操作系统核心提供，运行于内核态。

普通的函数调用由函数库或用户自己提供，运行于用户态。

系统调用的机制其核心是使用了操作系统为用户特别开放的一个**中断**实现的，该中断是程序人员自己开发出的一种**正常的异常**。

产生中断后，调用中断处理程序，调用System_call函数，就完成了操作系统内核态的调用。

# 并发和并行

+ 并发：在单个CPU中，**一个时刻**只有一个进程在运行，但是有多个线程在不断切换运行。
+ 并行：对于多个CPU，多个进程**同时**运行。

并发和并行的区别：并发的同时指的是不同线程在快速切换，看着像多个任务同时运行，但是同一时刻只有一个。并行是同一时刻有多个任务运行。

# 物理内存层次

+ 寄存器：速度最快，量少，价格贵
+ 高速缓存：次之。
+ 主存：再次之。
+ 磁盘：再次之。

![img](https://uploadfiles.nowcoder.com/images/20210329/675098158_1617017698529/09DD8C2662B96CE14928333F055C5580)

操作系统有一个**内存管理器**，主要工作是进行有效的内存管理。

# 存储类型

全部：

+ ROM
+ RAM
+ SRAM
+ DRAM
+ EPROM
+ PSRAM
+ EEPROM
+ FLASH
+ NOR FLASH
+ NAND FLASH

| 存储器类型 |                             简介                             |                             作用                             |
| :--------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|    ROM     |                只读存储器（Read-Only Memory）                | 是一种只能读出事先所存数据的固态半导体存储器。其特性是一旦储存资料就无法再将之改变或删除。 |
|    RAM     |   随机存取存储器（random access memory）又称作“随机存储器”   | 是与CPU直接交换数据的内部存储器，也叫主存(内存)。它可以随时读写，而且速度很快。 |
|    SRAM    |      静态随机存取存储器（Static Random-Access Memory）       | 随机存取存储器的一种。所谓的“静态”，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。然而，当电力供应停止时，SRAM储存的数据还是会消失。 |
|    DRAM    |                  动态随机存取存储器（DRAM）                  | DRAM里面所储存的数据就需要周期性地更新。要刷新充电一次，否则内部的数据即会消失。 |
|   EPROM    |         (Erasable Programmable ROM)，可擦除可编程ROM         | 芯片通过紫外线可重复擦除和写入,解决了PROM芯片只能写入一次的弊端。EPROM芯片在写入资料后,还要以不透光的贴纸或胶布把窗口封住,以免受到周围的紫外线照射而使资料受损。使用并不方便。 |
|   PSRAM    | 全称Pseudo static random access memory。指的是伪静态随机存储器。 | 内部的内存颗粒跟SDRAM的颗粒相似，但外部的接口跟SDRAM不同，不需要SDRAM那样复杂的控制器和刷新机制，PSRAM的接口跟SRAM的接口是一样的。PSRAM 内部自带刷新机制。 |
|   EEPROM   | (electrically erasable, programmable, read-only )是一种电可擦除可编程只读存储器 | 其内容在掉电的时候也不会丢失。在平常情况下，EEPROM与EPROM一样是只读的，需要写入时，在指定的引脚加 上一个高电压即可写入或擦除，而且其擦除的速度极快 |
|   Flash    |                              -                               | 它的主要特点是在不加电的情况下能长期保持存储的信息。就其本质而言，Flash Memory属于EEPROM(电擦除可编程只读存储器)类型。它既有ROM的特点，又有很高的存取速度，而且易于擦除和重写，功耗很小。 |
| NOR Flash  |                              -                               | NOR Flash的特点是芯片内执行(XIP, eXecute In Place)，这样应用程序可以直接在flash闪存内运行，不必再把代码读到系统RAM中。NOR Flash的传输效率很高，在1～4MB的小容量时具有很高的成本效益，但是很低的写入和擦除速度大大影响了它的性能。 |
| NAND Flash |                              -                               | NAND Flash结构能提供极高的单元密度，可以达到高存储密度，并且写入和擦除的速度也很快。应用NAND Flash的困难在于flash的管理需要特殊的系统接口。 |

# IO设备输入输出的三种方式

+ 循环：轮询循环检查设备
+ 中断
+ DMA

## 中断流程

**中断**是当出现需要时，CPU暂时停止当前进程的执行，转而执行处理新情况的中断处理程序。当执行完中断程序后，再进行执行当前进程。

为了区分不同中断，设备都有自己的中断号。

系统有0-255共**256**个中断，一张中断向量来存放256个中断的中断服务程序入口地址。

# 说说嵌入式中断的流程

**IRQ中断和FIQ中断都属于ARM的异常模式**

在ARM系统中，通常会进行以下步骤处理：

1. 保存现场。保存当前的PC值到R14。接着保存当前的程序运行状态到SPSR。

   > + PC(Program Counter)程序计数器
   >
   > + R14寄存器常用做链接寄存器(LR,Link Register)。当进入子程序时，常用来保存PC的返回值。
   >
   > + SPSR(Storage Program Status Register,程序状态备份寄存器)。

2. 模式切换，根据当前中断类型，进入IRQ模式或FIQ模式

   > IRQ为外部中断，FIQ是快速中断。
   >
   > 在进入大批量复制、数据传输等工作时，常使用FIQ

3. 获取中断源。

4. 中断处理

5. 中断返回。将SPSR中保存的程序运行状态恢复到CPSR，R14保存的被中断程序的地址恢复到PC，继续执行被中断的程序

   > CPSR(Current Program Status Register)当前程序状态寄存器。

# ARM的七种模式

|                         模式                         |                             意义                             |    模式    |   模式   |
| :--------------------------------------------------: | :----------------------------------------------------------: | :--------: | :------: |
|            用户模式（**usr**，User Mode）            |                 ARM处理器正常的程序执行状态                  | 非特权模式 | 普通模式 |
| 快速中断模式（**FIQ**，Fast Interrupt Request Mode） |  用于高速数据传输或通道处理。当触发**快速中断**时进入此模式  |  特权模式  | 异常模式 |
|   外部中断模式（**IRQ**，Interrupt Request Mode）    |      用于通用的中断处理。当触发**外部中断**时进入此模式      |  特权模式  | 异常模式 |
|         管理模式（**svc**，Supervisor Mode）         | 操作系统使用的保护模式。在系统复位或执行**软件中断指令SWI**时进入 |  特权模式  | 异常模式 |
|       数据访问中止模式（**abt**，Abort Mode）        |  当数据或指令预取中止时进入该模式，可用于虚拟存储及存储保护  |  特权模式  | 异常模式 |
|           系统模式（**sys**，System Mode）           |                  运行具有特权的操作系统任务                  |  特权模式  | 普通模式 |
|    未定义指令中止模式（**und**，Undefined Mode）     | 当未定义的指令执行时进入该模式，可用于支持硬件协处理器的软件仿真 |  特权模式  | 异常模式 |

# User模式和Supervisor模式有什么区别

+ User：是用户程序的工作模式，它运行在操作系统的**用户态**，没有权限去操作其他硬件资源，只能执行处理自己的数据，也不能切换到其他模式下。要想访问硬件资源或切换到其他模式必须通过**软中断**或产生**异常**
+ Supervisor：是CPU上电后默认模式，在该模式下进行系统的初始化，软处理也在该模式下。当用户模式下的用户程序请求使用硬件资源时，通过软件中断进入该模式。

---

Supervisor相比于IRQ和FIQ通过硬件触发，优先级更低，而且时软件触发。

# 软中断

Linux将中断处理分为两个部分：**上半部**和**下版本**

上半部(硬中断)：用于快速处理中断。它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作。

下半部(软中断)：用来延迟处理上半部未完成的工作，通常以内核线程的方式运行。

**举个例子：**网卡接收到数据包后，会通过**硬件中断**的方式，通知内核有新的数据来了。之后内核开始调用中断处理程序来响应它。

+ 对上半部来讲，既然是快速处理，其实就是要把网卡的数据读至内存，然后更新一下硬件寄存器的状态(表示已经读好了)。再发送一个**软中断**信号，通知下半部做进一步处理
+ 下半部接收到**软中断**信号后，从内存找到网络数据，按照网络协议栈，对数据进行逐层解析和处理，直到送至应用程序。

所以，这两个阶段你也可以这样理解：

- 上半部直接处理硬件请求，也就是我们常说的**硬中断**，特点是快速执行；
- 而下半部则是由内核触发，也就是我们常说的**软中断**，特点是延迟执行。

# DMA

Direct Memory Access

直接控制外围设备的数据流，不需要持续的CPU干预。

## DMA使用场景

主要用于**高速大批量数据传送的系统中，以提高数据的吞吐量**。如**磁盘存取，图像处理，高速数据采集系统**等。

## DMA设置

因为无需CPU干预，DMA需要进行软件设置：

+ 源地址
+ 目的地址
+ 触发源(什么时候开始传)

# Linux启动工程

- 内核的引导。
- 运行 init。
- 系统初始化。
- 建立终端 。
- 用户登录系统。

# Linux 指令

## 查看进程运行状态的指令

```
ps -aux | grep PID
```

用于查看某PID进程状态

## 查看内存使用情况的指令

```
free - m
```

## tar解压文件的参数

```
五个命令中必选一个
     -c: 建立压缩档案
     -x：解压
     -t：查看内容
     -r：向压缩归档文件末尾追加文件
     -u：更新原压缩包中的文件
这几个参数是可选的
     -z：有gzip属性的
     -j：有bz2属性的
     -Z：有compress属性的
     -v：显示所有过程
     -O：将文件解开到标准输出
```

以上比如说：

```
//ps使用示例
//显示当前所有进程  
ps -A  
//与grep联用查找某进程  
ps -aux | grep apache  

//查看进程运行状态、查看内存使用情况的指令均可使用top指令。
top
```

# Linux文件权限怎么改

Linux文件的基本权限有9个

+ 三种身份：owner/group/others
+ 三种身份各有三种权限：read/write/execute(可执行)

修改权限指令：`# chmod [-R] xyz 文件或目录`

举个例子：

想要变更一个文件的权限字符为`-rwxrwx---`

+ 第一个字符：文件类型。
  + 文件：`-`
  + 文件夹：`d`
  + 链接文件：`-`
  + 块设备：`b`
  + 字符设备：`c`
+ 第234个字符：owner的权限。
+ 第567个字符：group的权限
+ 第8910个字符：others的权限

每个权限有分数对照，每个身份为分数累加。

所以这个文件的**xyz权限数字**为770

+ owner：rwx=4+2+1
+ group：rwx=4+2+1
+ others：--- = 0+0+0

```
# chmod 770 douya.c //修改douya.c文件的权限为770
-R:进行递归(recursize)的持续变更，使同次目录下的属性均发送相同更改
```

# Linux常见的权限命令



|    命令    |                             功能                             |
| :--------: | :----------------------------------------------------------: |
|    man     |                           帮助命令                           |
|   ls命令   |                    查看当前文件与目录信息                    |
|   cd命令   |                       用于切换当前目录                       |
|  pwd命令   |                      用于显示工作目录。                      |
| mkdir命令  |                  mkdir 命令用于创建文件夹。                  |
|   rm命令   |                     删除文件或文件夹命令                     |
| rmdir 命令 |              从一个目录中删除一个或多个子目录项              |
|   mv命令   |                     移动文件或文件夹命令                     |
|   cp命令   |                           复制命令                           |
|  cat命令   |                    查看文件内容；连接文件                    |
|  more命令  |               more 会以一页一页的显示文件内容                |
|  less命令  |       less 与 more 类似，但使用 less 可以随意浏览文件        |
|  grep命令  | 该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工。 |
|   ps命令   |                         查看进程情况                         |
|  top命令   |    可以查看操作系统的信息，如进程、CPU占用率、内存信息等     |
|  kill命令  |                      向进程发送终止信号                      |

# Linux 如何以root权限运行某个程序

输入以下两条命令即可

```
sudo chown root app(文件名)
sudo chown u+s app(文件名)
```

# 常见信号有哪些？表示什么含义？

1 9 15 17 比较重要。

| 信号代号 | 信号名称 |                            说 明                             |
| :------: | :------: | :----------------------------------------------------------: |
|    1     |  SIGHUP  |      该信号让进程立即关闭.然后重新读取配置文件之后重启       |
|    2     |  SIGINT  |   程序中止信号，用于中止前台进程。相当于输出 Ctrl+C 快捷键   |
|    8     |  SIGFPE  | 在发生致命的算术运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为 0 等其他所有的算术运算错误 |
|    9     | SIGKILL  | 用来立即结束程序的运行。本信号不能被阻塞、处理和忽略。般用于强制中止进程 |
|    14    | SIGALRM  | 时钟定时信号，计算的是实际的时间或时钟时间。alarm 函数使用该信号 |
|    15    | SIGTERM  | 正常结束进程的信号，kill 命令的默认信号。如果进程已经发生了问题，那么这 个信号是无法正常中止进程的，这时我们才会尝试 SIGKILL 信号，也就是信号 9 |
|    17    | SIGCHLD  |             子进程结束时, 父进程会收到这个信号。             |
|    18    | SIGCONT  |       该信号可以让暂停的进程恢复执行。本信号不能被阻断       |
|    19    | SIGSTOP  | 该信号可以暂停前台进程，相当于输入 Ctrl+Z 快捷键。本信号不能被阻断 |

# 进程概念

## Linux操作系统的进程结构

+ 代码段：存放程序代码。多个进程运行相同一个程序，使用同一个代码段。
+ 数据段：存放程序的全局变量、常量和静态变量
+ 堆栈段：栈用于函数调用，存放着函数的参数、局部变量。

## 程序如何转换为进程

一个程序生成分为四个阶段：**预编译、编译、汇编和链接**，最后生成可执行文件。

当程序执行时，操作系统将**可执行文件**复制到内存中，经过以下几个步骤转换为**进程**：

1. 内核将程序读入内存，为程序分配内存空间，打包成一个**进程**。
2. 内核为该进程分配**进程标识符(PID)**和其他资源。
3. 内核为进程保存PID及相应的状态信息，将进程放入运行队列中等待执行。
4. 操作系统调度执行这一个包装成进程的程序。

> 我们来举个例子，比如我们写一个C文件，里面包含了一个**main函数**，在操作系统里编译然后运行，经过上述一系列步骤，那么操作系统就将这个**执行程序**“包装”成一个**进程**，进程里面再创建一个线程来执行这个可执行文件。过程就是如此。

**现在的系统都是多线程的体系。**

一个进程对应**唯一标识符PID**。标识符类型为pid_t，是一个无符号整型。

同一个可执行程序可以被加载为多个不同的进程。**因此进程与PID是一对一关系，而进程与程序文件之间是多对一关系。**

## 进程的五种状态

有 创建、就绪、执行、阻塞、终止。

![img](https://uploadfiles.nowcoder.com/images/20210329/675098158_1617018568876/FB5C81ED3A220004B71069645F112867)

+ **创建状态**：一个应用程序从系统上启动，首先就是进入**创建状态**，需要获取系统资源创建进程管理块（PCB：Process Control Block）完成资源分配。
+ **就绪状态**：在**创建状态**完成之后，进程已经准备好，处于**就绪状态**，但是还未获得处理器资源，无法运行。
+ **执行状态**：获取处理器资源，被系统调度，**当具有时间片**开始进入**执行状态**。如果进程的时间片用完了就进入**就绪状态**。
+ **阻塞状态**：在**运行状态**期间，如果进行了阻塞的操作，如**耗时**的I/O操作，此时进程暂时无法操作就进入到了**阻塞状态**，在这些**操作**完成后就进入**就绪状态**。等待再次获取处理器资源，被系统调度，**当具有时间片**就进入**运行状态**。
+ **终止状态**：进程结束或被系统终止，进入终止状态。

## 进程创建方式

+ 由操作系统创建
+ 父进程创建子进程

---

## 父进程创建子进程的关系和区别

系统允许一个进程创建新进程（即子进程），子进程又可以创建新的子进程，形成树结构。

子进程从父进程继承的主要有：

+ 用户号和用户组号；
+ 堆栈；
+ 共享内存；
+ 目录（当前目录、根目录）；
+ 打开文件的描述符；
+ 但父进程和子进程拥有独立的地址空间和PID参数、不同的父进程号、自己的文件描述符。

## Linux的fork函数作用

fork函数用来创建一个进程。

+ 对于父进程使用fork，会返回新创建的子进程的PID

+ 对于子进程，fork函数调用成功会返回0。

+ 如果创建出错，fork函数返回-1。

**详细来讲**：

fork()函数创建一个新进程后，会为这个新进程分配进程空间，**将父进程的进程空间中的内容复制到子进程的进程空间中，包括父进程的数据段和堆栈段**，并且和父进程共享代码段。这时候，子进程和父进程一模一样，都接受系统的调度。因为两个进程都停留在fork()函数中，最后fork()函数会返回两次，一次在父进程中返回，一次在子进程中返回，两次返回的值不一样，如上面的三种情况。

## 写时复制

创建新进程时，连数据段和堆栈段都不再立马复制了，而是**等到需要**修改数据段或堆栈段的数据时再复制，这就是**写时复制**。

节省了进程空间，效率更高。

## 什么是守护进程，如何创建

守护进程是运行在后台的一种生存期长的特殊进程。它独立与控制终端，处理一些系统级别任务。

**创建过程**如下：

1. **创建子进程，终止父进程**。
2. **调用setsid()创建一个新会话**。
   1. **将当前目录更改为根目录**。
   2. **重设文件权限掩码**。
   3. **关闭不再需要的文件描述符**。

## 孤儿进程和僵尸进程？如何解决

+ 孤儿进程

  指一个父进程退出，它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。

  孤儿进程会被init进程(PID=1)收养，并且由init进程对他们完成状态收集工作。

+ 僵尸进程

  是指一个进程使用fork函数创建子进程，如果子进程退出，而父进程并没有调用wait()或者waitpid()系统调用取得子进程的终止状态，**那么子进程的进程描述符仍然保存在系统中，占用系统资源，**这种进程称为僵尸进程。

两者区别：

+ 孤儿进程是父退子留。
+ 僵尸进程是父留子退。

如何解决僵尸进程：

+ 一般，为了防止产生僵尸进程，在fork子进程之后我们要及时使用**wait系统调用**。同时，当子进程退出时，内核都会给父进程一个SIGCHLD信号，可以利用这一个信号建立捕获信号处理函数，在函数体内调用wait，就可以清理退出的子进程防止产生僵尸进程。
+ 使用kill命令，强制杀死父进程。

## wait函数的作用

`wait`用来及时回收我们的进程资源。

进程一旦调用了`wait`，就会立刻**阻塞**自己本身，然后由`wait`分析出当前进程的子进程是否已经退出。如果发现僵尸进程，就将它彻底销毁，直到将该进程的所有子进程检查完毕。

## 进程通信

进程间通信主要包括

+ 管道
+ 系统IPC（包括消息队列、信号量、信号、共享内存）
+ 套接字socket

---

+ 管道
  + 无名管道：半双工，只能用于具有亲缘关系进程的通信（父子、兄弟）
  + 命名管道：允许无亲缘进程的通信
+ 系统IPC
  + 消息队列：消息的链接表，放在内核中。**消息队列独立于发送与接收进程**，进程终止时，消息队列及其内容并不会被删除；消息队列可以实现消息的随机查询，可以按照消息的类型读取。
  + 信号量semaphore：是一个**计数器**，可以用来控制多个进程对共享资源的访问。信号量常用于实现进程间的互斥与同步。
  + 信号：用于通知接收进程某个事件的发生
  + 内存共享：使多个进程访问同一块内存空间
+ 套接字socket：用于不同主机的直接通信。

## 进程同步的方式？

+ 信号量semaphore：是一个计数器,可以控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步。P操作(递减操作)可以用于阻塞一个进程，V操作(增加操作)可以用于解除阻塞一个进程。
+ 管道：一个进程通过调用管程的一个过程进入管程。在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用。
+ 消息队列：消息的链接表，放在内核中。消息队列独立于发送与接收进程，进程终止时，消息队列及其内容并不会被删除；消息队列可以实现消息的随机查询，可以按照消息的类型读取。
+ 互斥锁：

## 进程通信中的管道实现原理是什么？

操作系统在内核中开辟一块**缓冲区**用于通信，称为管道。

管道是单向性，所以又被称为单双工管道。

> 单双工：一个发送，一个接收，方向不能换。
>
> 全双工：两条单双工道组成，可以互相发送和接收。

如果是全双工管道，需要建立两个管道：无名管道和命名管道。

## 进程的空间模型（内存都有啥）

系统为其分配4G的虚拟地址空间，其中0-3G是用户空间，3-4G是内核空间。内核空间是受保护的，用户不能对该空间进行读写操作。

栈区：由编译器自动分配和释放，存放函数的参数值（形参）、局部变量

堆区：一般由程序员分配和释放

全局区（静态区）、文字常量区，程序代码区

# 信号量

## 什么是信号量

信号量本质是一个计数器，用于**多进程**对共享数据对象的读读取，主要用来保护共享资源。

## 信号量的工作原理

信号量只能进行两种操作：等待P(sv)和发送V(sv)。

+ P(sv)：如果sv>0，就-1。如果sv=0，就挂起该进程的执行。

  信号量的值为**正**，进程获得该资源的使用权，进程将信号量-1，表示它使用了一个资源单位。

+ V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它+1。(若此时信号量的值为0，则进程进入挂起状态，直到信号量的值大于0，若进程被唤醒则返回至第一步）

## 信号量的作用

用于多进程对共享数据对象的读取，主要用来保护共享资源，使得资源在一个时间可以有多个进程对资源的访问。

# 多进程内存共享会存在什么问题，如果处理

并发时，一个修改数据，一个正在读数据，就会产生bug。

共享内存时要考虑同步问题。

加入**互斥量**或者**信号量**实现同步。

# 一个线程占多大的内存

一个linux的线程大概占8M内存。

# 32位系统可以访问4GB以上内存吗？

正常情况下不可以。计算机使用二进制进行数据处理，2的32位是4G，所以大于4G计算机是没办法处理。只能换成64位操作系统。

但是可以使用**PAE**技术来实现32位系统访问4GB以上的内存。

# 进程、线程、协程的区别是什么？

+ 进程：程序是指令、数据及其组织形式的描述，而进程是程序的运行实例，包括程序计数器、寄存器和变量的当前值。
+ 线程：一个进程里更小粒度的执行单元，一个进程可以包含多个线程并发进行任务。
+ 协程：协程是微线程，在子程序内部执行，可在子程序内部中断，转而执行别的子程序，在适当的时候再返回来接着执行。

## 进程与线程的区别

（1）一个线程从属于一个进程；一个进程可以包含多个线程。

（2）一个线程挂掉，对应的进程挂掉；一个进程挂掉，不会影响其他进程。

（3）进程是系统资源调度的最小单位；线程CPU调度的最小单位。

（4）进程系统开销显著大于线程开销；线程需要的系统资源更少。

（5）进程在执行时拥有独立的内存单元，多个线程共享进程的内存，如代码段、数据段、扩展段；但每个线程拥有自己的栈段和寄存器组。

（6）进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈，线程切换时只需要切换硬件上下文和内核栈。

（7）通信方式不一样。

（8）进程适应于多核、多机分布；线程适用于多核

## 线程与协程的区别

（1）协程执行效率极高。协程直接操作栈基本没有内核切换的开销，所以上下文的切换非常快，切换开销比线程更小。

（2）协程不需要多线程的锁机制，因为多个协程从属于一个线程，不存在同时写变量冲突，效率比线程高。

（3）一个线程可以有多个协程。

## 协程是轻量级线程，轻量级表现在哪里？

1. **协程调用跟切换比线程效率高**：协程执行效率极高。协程不需要多线程的锁机制，可以不加锁的访问全局变量，所以上下文的切换非常快。
2. **协程占用内存少**：执行协程只需要极少的栈内存（大概是4～5KB），而默认情况下，线程栈的大小为1MB。
3. **切换开销更少**：协程直接操作栈基本没有内核切换的开销，所以切换开销比线程少。

# 互斥量能在进程中使用吗?

可以

+ 不同的进程之间，存在资源竞争或并发使用的问题，就需要**互斥量**。

+ 在进程内部，线程与线程之间需要通过互斥的手段进行同步，避免导致共享数据修改引起冲突，可以使用**互斥锁**，属于**互斥量**的一种。

****

# 线程间的通信方式有什么？

线程间的通信方式包括

+ 互斥锁
+ 信号量
+ 条件变量
+ 读写锁

---

+ 互斥锁：采用互斥对象机制。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。

+ 信号量：计数器，允许多个线程同时访问用一个资源。
+ 条件变量：通过条件变量通知操作的方式来保持多线程同步。
+ 读写锁：读写锁与互斥量类似。但互斥量要么是锁住状态，要么是不加锁状态。读写锁一次只允许一个线程写，但允许一次多个线程读，这样效率比互斥锁高。

# 互斥量与信号量的区别

+ 互斥量用于线程间的互斥，信号量用于线程的同步
+ 互斥量只能为0or1，信号量值为非负数。
+ 互斥锁保证资源同一时间只有一个线程访问；信号量可以多个线程访问同一资源。

# 有了进程，为什么还要有线程

1. **原因**

   进程在早期的多任务操作系统中是基本的**执行单元**。每次进程切换，都要先保存进程资源然后再恢复，这称为上下文切换。**但是进程频繁切换将引起额外开销，从而严重影响系统的性能。**为了减少进程切换的开销，人们把两个任务放到一个进程中，每个任务用一个更小**粒度**的执行单元来实现并发执行，这就是**线程**。

2. **线程与进程对比**

   （1）**进程间的信息难以共享。**由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通信方式，在进程间进行信息交换。

   但**多个线程共享**进程的内存，如代码段、数据段、扩展段，线程间进行信息交换十分方便。

   （2）调用 fork() 来创建进程的代价相对较高，即便利用写时复制技术，仍然需要复制诸如内存页表和文件描述符表之类的多种进程属性，这意味着 fork() 调用在时间上的开销依然不菲。

   **但创建线程比创建进程通常要快 10 倍甚至更多。**线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表。

# 单核机器写多线程程序，是否要考虑加锁，为什么

在单核机器上写多线程程序，仍然需要线程锁。

**原因**：因为线程锁通常用来实现线程的同步和通信。在单核机器上的多线程程序，仍然存在线程同步的问题。因为在抢占式操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。如果这两个线程共享某些数据，**不使用线程锁的前提下，可能会导致共享数据修改引起冲突。**

# 说说多线程和多进程的不同？

（1）一个线程从属于一个进程；一个进程可以包含多个线程。

（2）一个线程挂掉，对应的进程挂掉，多线程也挂掉；一个进程挂掉，不会影响其他进程，多进程稳定。

（3）进程系统开销显著大于线程开销；线程需要的系统资源更少。

（4）多个进程在执行时拥有各自独立的内存单元，多个线程共享进程的内存，如代码段、数据段、扩展段；但每个线程拥有自己的栈段和寄存器组。

（5）多进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈；多线程切换时只需要切换硬件上下文和内核栈。

（6）通信方式不一样。

（7）多进程适应于多核、多机分布；多线程适用于多核

# 简述互斥锁的机制，互斥锁与读写的区别

1. **互斥锁机制**：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入阻塞，等待锁释放。

2. **互斥锁和读写锁**：

   （1） 读写锁区分读者和写者，而互斥锁不区分

   （2）互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。

# 一个线程正在进行读。另一个线程尝试加写锁，写锁优先级高于读锁，那这个正在读的线程会让出来资源吗

不会。**一次只有一个线程可以对其加锁**，不论是加读锁还是加写锁。

# 写锁优先级高于读锁什么意思

优先级的意思是，当有两个线程处于阻塞状态时，一个尝试读，一个尝试写，写锁优先级高于读锁，**当锁可以获取时，那么尝试写的线程先加锁**。

# 说说线程池的设计思路，线程池中线程的数量由什么确定？

1. **设计思路**：

   实现线程池有以下几个步骤：
   （1）设置一个生产者消费者队列，作为临界资源。

   （2）初始化n个线程，并让其运行起来，加锁去队列里取任务运行

   （3）当任务队列为空时，所有线程阻塞。

   （4）当生产者队列来了一个任务后，先对队列加锁，把任务挂到队列上，然后使用条件变量去通知阻塞中的一个线程来处理。

2. **线程池中线程数量**：

   线程数量和哪些因素有关：CPU，IO、并行、并发

   如果是CPU密集型应用，则线程池大小设置为：CPU数目+1
   如果是IO密集型应用，则线程池大小设置为：2*CPU数目+1
   最佳线程数目 = （线程等待时间与线程CPU时间之比 + 1）* CPU数目

   所以线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。

3. **为什么要创建线程池**：

   创建线程和销毁线程的花销是比较大的，这些时间有可能比处理业务的时间还要长。这样频繁的创建线程和销毁线程，再加上业务工作线程，消耗系统资源的时间，可能导致系统资源不足。**同时线程池也是为了提升系统效率。**

4. **线程池的核心线程与普通线程：**

   任务队列可以存放100个任务，此时为空，线程池里有10个核心线程，若突然来了10个任务，那么刚好10个核心线程直接处理；若又来了90个任务，此时核心线程来不及处理，那么有80个任务先入队列，再创建核心线程处理任务；若又来了120个任务，此时任务队列已满，不得已，就得创建20个普通线程来处理多余的任务。
   **以上是线程池的工作流程。**

# 进程和线程相比，为什么慢？

1. 进程系统开销显著大于线程开销；线程需要的系统资源更少。
2. 进程切换开销比线程大。多进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈；多线程切换时只需要切换硬件上下文和内核栈。
3. 进程通信比线程通信开销大。进程通信需要借助管道、队列、共享内存，需要额外申请空间，通信繁琐；而线程共享进程的内存，如代码段、数据段、扩展段，通信快捷简单，同步开销更小。

# 什么是死锁？产生条件，如何解决？

**死锁**：是指多个线程在执行过程中，因争夺资源而造成了**互相等待**，此时系统产生了死锁。

> 比如两头羊站在桥的两头，都要争着过桥，最后谁也过不去。

**产生条件**：

+ 互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问，只能等待，直到进程使用完成后释放该资源；
+ 请求保持条件：进程获得一定资源后，又对其他资源发出请求，但该资源被其他进程占有，此时请求阻塞，而且该进程不会释放自己已经占有的资源
+ 不可剥夺条件：进程已获得的资源，只能自己释放，不可剥夺；
+ 环路等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

**如何解决：**

+ 资源一次性分配，从而解决请求保持的问题
+ 可剥夺资源：当进程新的资源未得到满足时，释放已有的资源。
+ 资源有序分配：资源按序号递增，进程请求按递增请求，释放则相反。

## 死锁与活锁

死锁：。。。

活锁：指线程1可以使用资源，但是很有礼貌，让其他线程先使用资源。线程2也很有礼貌，让其他线程先用。这样你让我我让你，最后2个线程都无法使用资源。

# 互斥锁的机制-mutex

**互斥锁的机制**：在任何时刻，都只能有一个线程访问对象。当获取锁操作失败时，线程进入阻塞，等待锁释放。

**互斥锁与读写锁的区别**：

+ 读写锁区分读者与写者，互斥锁不区分。
+ 互斥锁同一时间只允许一个线程访问该对象，无论读写。读写锁同一时间只允许一个线程写，但读不限制。

# 简述自旋锁和互斥锁的使用场景

1. 互斥锁：

   用于临界区持锁时间比较长的操作，比如下面这些情况都可以考虑

　　（1）临界区有IO操作

　　（2）临界区代码复杂或者循环量大

　　（3）临界区竞争非常激烈

　　（4）单核处理器

2. 自旋锁：主要用在临界区持锁时间非常短且CPU资源不紧张的情况下。

   > 自旋锁指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。

# 公平锁和非公平锁

**公平锁**：就是很公平，在并发环境中，每个线程在获取锁时会先**查看此锁维护的等待队列**，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己
**非公平锁**：非公平锁比较粗鲁，**上来就直接尝试占有锁**，如果尝试失败，就再采用类似公平锁那种方式。
非公平锁的优点在于吞吐量比公平锁大。

# 乐观锁和悲观锁

+ 乐观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。**乐观锁适用于多读的应用类型，这样可以提高吞吐量**，
+ 悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**）。

# 说说slepl和wait的区别

sleep：是一个延时函数，让进程或线程进入休眠。休眠后继续允许。

wait：父进程回收子进程的一个系统调用

# 简述同步与异步的区别。

**同步**：所有的操作都做完，才返回给用户结果。即**写完数据库**之后，**再响应用户**，用户体验不好。双方的动作是经过双方协调的，步调一致的。

**异步**：不用等所有操作都做完，就响应用户请求。即**先响应用户请求**，然后**慢慢去写数据库**，用户体验较好。双方并不需要协调，都可以随意进行各自的操作。

# 简述阻塞与非阻塞的区别

**阻塞**：调用者调用了某个函数，等待这个函数返回，期间什么也不做，**不停**的检查这个函数有没有返回，必须等这个函数返回后才能进行下一步动作。

**非阻塞**：非阻塞等待，每**隔一段时间**就去检查IO事件是否就绪。没有就绪就可以做其他事情。

# FreeRTOS

## 实时操作系统是怎么实现的

相比于裸机系统是在一个while(1)里实现，实时系统通过任务调度进行各个任务之间的切换

任务调度可以分**抢占调度**和**轮询调度**

## 优先级翻转/优先级反转

当**高优先级任务**正等待信号量（此信号量被一个低优先级任务拥有着）的时候，一个**介于**两个任务优先之间的中等优先级任务开始执行——这就会导致一个高优先级任务在等待一个低优先级任务，而低优先级任务却无法执行类似死锁的情形发生。

改进方法：

+ **优先级继承**：让低优先级线程在获得同步资源的时候(如果有高优先级的线程也需要使用该同步资源时)，**临时**提升其优先级。以前其能更快的执行并释放同步资源。释放同步资源后再恢复其原来的优先级。

## 调度算法

1. **先来先服务调度算法**：在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。
2. **短作业(进程)优先调度算法**：而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它。
3. **时间片轮转算法**：系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU分配给队首进程，并令其**执行一个时间片**。时间片的大小从几ms到几百ms。当执行的时间片用完时，由**一个计时器**发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它**执行一个时间片**。

# STM32芯片启动流程

+ 设置BOOT1和BOOT0引脚的状态，来选择在复位后的启动模式。

  + **Main Flash memory**

    STM32内置的Flash，一般我们使用JTAG或者SWD模式下载程序时，就是下载到这个里面，重启后也直接从这启动程序

  + **System memory**

    种模式启动的程序功能是由厂家设置，出厂无法修改。由于某种原因导致内部Flash锁死，无法连接SWD以及Jtag调试，无法读到设备，可以通过修改BOOT模式重新刷写代码。

  + **Embedded Memory**

    这个模式一般用于程序调试。假如我只修改了代码中一个小小的地方，然后就需要重新擦除整个Flash，比较的费时，可以考虑从这个模式启动代码

+ 启动文件由汇编编写，是系统上电复位后第一个执行的程序。主要做了以下工作：

  1、初始化堆栈指针SP=_initial_sp

  2、初始化PC指针=Reset_Handler

  3、初始化中断向量表

  4、配置系统时钟

  5、调用C库函数_main初始化用户堆栈，从而最终调用main函数去到C的世界

# STM32 Flash-存储程序

+ 主存储器：keil把程序烧写的地方
+ 系统存储器 bootloader:存储一段特殊的出厂程序，可以对主存储器进行重新烧写
+ 一次性可编程区域OTP

# STM32 SRAM-存储中间变量



# Linux内核

只是会用常用的linux进行服务器管理，用linux的vi写代码，gcc编译，gdb调试

Linux内核有5大模块：

+ 进程调度
+ 进程通信
+ 内存管理(虚拟存储)
+ 文件系统(虚拟文件系统)
+ 网络接口(使用套接字Socket)